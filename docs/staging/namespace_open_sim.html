<!-- HTML header for doxygen 1.8.16-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenSim Moco: OpenSim Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen-style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenSim Moco
   &#160;<span id="projectnumber">0.1.0-2019-11-17-adcad0ad</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">OpenSim Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Moco interface is contained within the <a class="el" href="namespace_open_sim.html" title="The Moco interface is contained within the OpenSim namespace. ">OpenSim</a> namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_acceleration_motion.html">AccelerationMotion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a thin wrapper to Simbody's SimTK::Motion for prescribing the acceleration of all degrees of freedom (UDot), and is used when enforcing dynamics using implicit differential equations (UDot is supplied by the solver, not by Simbody).  <a href="class_open_sim_1_1_acceleration_motion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_ackermann_van_den_bogert2010_force.html">AckermannVanDenBogert2010Force</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is still under development.  <a href="class_open_sim_1_1_ackermann_van_den_bogert2010_force.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_activation_coordinate_actuator.html">ActivationCoordinateActuator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to CoordinateActuator (simply produces a generalized force) but with first-order linear activation dynamics.  <a href="class_open_sim_1_1_activation_coordinate_actuator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_de_groote_fregly2016_muscle.html">DeGrooteFregly2016Muscle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This muscle model was published in De Groote et al.  <a href="class_open_sim_1_1_de_groote_fregly2016_muscle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_discrete_forces.html">DiscreteForces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a thin wrapper to Simbody's SimTK::Force::DiscreteForces class.  <a href="class_open_sim_1_1_discrete_forces.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_esposito_miller2018_force.html">EspositoMiller2018Force</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This contact model uses a continuous equation to transition between in and out of contact.  <a href="class_open_sim_1_1_esposito_miller2018_force.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_file_deletion_thrower.html">FileDeletionThrower</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class helps a user cause an exception within the code.  <a href="class_open_sim_1_1_file_deletion_thrower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_file_deletion_thrower_exception.html">FileDeletionThrowerException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown by FileDeletionThrower::throwIfDeleted().  <a href="class_open_sim_1_1_file_deletion_thrower_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_sim_1_1make__printable__return.html">make_printable_return</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for <a class="el" href="namespace_open_sim.html#a3d3c4fa14d4de297beb390cadb031ad4" title="Convert to types that can be printed with sprintf() (vsnprintf()). ">make_printable()</a>  <a href="struct_open_sim_1_1make__printable__return.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_sim_1_1make__printable__return_3_01std_1_1string_01_4.html">make_printable_return&lt; std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for std::string.  <a href="struct_open_sim_1_1make__printable__return_3_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_meyer_fregly2016_force.html">MeyerFregly2016Force</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This contact model is from the following paper: Meyer A.  <a href="class_open_sim_1_1_meyer_fregly2016_force.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_average_speed_goal.html">MocoAverageSpeedGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This goal requires the average speed of the system to match a desired average speed.  <a href="class_open_sim_1_1_moco_average_speed_goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_bounds.html">MocoBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small struct to handle bounds.  <a href="class_open_sim_1_1_moco_bounds.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_cas_a_di_solver.html">MocoCasADiSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This solver uses the CasADi library (<a href="https://casadi.org">https://casadi.org</a>) to convert the <a class="el" href="class_open_sim_1_1_moco_problem.html" title="A description of an optimal control problem, backed by OpenSim Models. ">MocoProblem</a> into a generic nonlinear programming problem.  <a href="class_open_sim_1_1_moco_cas_a_di_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_cas_o_c_problem.html">MocoCasOCProblem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the bridge between <a class="el" href="class_cas_o_c_1_1_problem.html">CasOC::Problem</a> and <a class="el" href="class_open_sim_1_1_moco_problem_rep.html" title="The primary intent of this class is for use by MocoSolvers, but users can also use this class to appl...">MocoProblemRep</a>.  <a href="class_open_sim_1_1_moco_cas_o_c_problem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_constraint_info.html">MocoConstraintInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information for a given constraint in the optimal control problem.  <a href="class_open_sim_1_1_moco_constraint_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_control_bound_constraint.html">MocoControlBoundConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class constrains any number of control signals from ScalarActautors to be between two time-based functions.  <a href="class_open_sim_1_1_moco_control_bound_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_control_goal.html">MocoControlGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize the sum of the absolute value of the controls raised to a given exponent, integrated over the phase.  <a href="class_open_sim_1_1_moco_control_goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_control_tracking_goal.html">MocoControlTrackingGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The squared difference between a control variable value and a reference control variable value, summed over the control variables for which a reference is provided, and integrated over the phase.  <a href="class_open_sim_1_1_moco_control_tracking_goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_direct_collocation_solver.html">MocoDirectCollocationSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a base class for solvers that use direct collocation to convert an optimal control problem into a generic nonlinear programming problem.  <a href="class_open_sim_1_1_moco_direct_collocation_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_final_bounds.html">MocoFinalBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for specifying the bounds on a variable at the end of a phase.  <a href="class_open_sim_1_1_moco_final_bounds.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_final_time_goal.html">MocoFinalTimeGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint cost for final time.  <a href="class_open_sim_1_1_moco_final_time_goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_goal.html">MocoGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A goal is term in the cost functional to be minimized, or a set of endpoint constraints that must lie within provided bounds.  <a href="class_open_sim_1_1_moco_goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_initial_activation_goal.html">MocoInitialActivationGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For all muscles with activation dynamics, the initial activation and initial excitation should be the same.  <a href="class_open_sim_1_1_moco_initial_activation_goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_initial_bounds.html">MocoInitialBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for specifying the bounds on a variable at the start of a phase.  <a href="class_open_sim_1_1_moco_initial_bounds.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_initial_force_equilibrium_goal.html">MocoInitialForceEquilibriumGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For all Muscle components with explicit tendon compliance dynamics, constrain (or minimize) the error computed from the muscle-tendon force equilibrium equation.  <a href="class_open_sim_1_1_moco_initial_force_equilibrium_goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_initial_velocity_equilibrium_d_g_f_goal.html">MocoInitialVelocityEquilibriumDGFGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <a class="el" href="class_open_sim_1_1_de_groote_fregly2016_muscle.html" title="This muscle model was published in De Groote et al. ">DeGrooteFregly2016Muscle</a> components with implicit tendon compliance dynamics, the initial tendon and fiber velocities are determined based the derivative of the linearized muscle-tendon equilibrium equation described in Millard et al.  <a href="class_open_sim_1_1_moco_initial_velocity_equilibrium_d_g_f_goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_inverse.html">MocoInverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This tool solves problems in which the kinematics are prescribed and you seek the actuator (e.g., muscle) behavior that may have given rise to the provided kinematics.  <a href="class_open_sim_1_1_moco_inverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_inverse_solution.html">MocoInverseSolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds the solution from <a class="el" href="class_open_sim_1_1_moco_inverse.html" title="This tool solves problems in which the kinematics are prescribed and you seek the actuator (e...">MocoInverse</a>.  <a href="class_open_sim_1_1_moco_inverse_solution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_joint_reaction_goal.html">MocoJointReactionGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize the sum of squares of specified reaction moment and force measures for a given joint, integrated over the phase.  <a href="class_open_sim_1_1_moco_joint_reaction_goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_kinematic_constraint.html">MocoKinematicConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A model kinematic constraint to be enforced in the optimal control problem.  <a href="class_open_sim_1_1_moco_kinematic_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_marker_final_goal.html">MocoMarkerFinalGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The squared distance between a single model point location and reference location in the final state.  <a href="class_open_sim_1_1_moco_marker_final_goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_marker_tracking_goal.html">MocoMarkerTrackingGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The squared difference between a model marker location and an experimental reference marker location, summed over the markers for which an experimental data location is provided, and integrated over the phase.  <a href="class_open_sim_1_1_moco_marker_tracking_goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_orientation_tracking_goal.html">MocoOrientationTrackingGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The squared difference between a model frame's orientation and a reference orientation value, summed over the frames for which a reference is provided, and integrated over the phase.  <a href="class_open_sim_1_1_moco_orientation_tracking_goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_parameter.html">MocoParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_open_sim_1_1_moco_parameter.html" title="A MocoParameter allows you to optimize property values in an OpenSim Model. ">MocoParameter</a> allows you to optimize property values in an <a class="el" href="namespace_open_sim.html" title="The Moco interface is contained within the OpenSim namespace. ">OpenSim</a> Model.  <a href="class_open_sim_1_1_moco_parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_path_constraint.html">MocoPathConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A path constraint to be enforced in the optimal control problem.  <a href="class_open_sim_1_1_moco_path_constraint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_periodicity_goal.html">MocoPeriodicityGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This goal enforces equality between initial and final variable values in the optimal control problem.  <a href="class_open_sim_1_1_moco_periodicity_goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_periodicity_goal_pair.html">MocoPeriodicityGoalPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create pair of variables for use with a <a class="el" href="class_open_sim_1_1_moco_periodicity_goal.html" title="This goal enforces equality between initial and final variable values in the optimal control problem...">MocoPeriodicityGoal</a>.  <a href="class_open_sim_1_1_moco_periodicity_goal_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_phase.html">MocoPhase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The states, controls, dynamics, parameters, goals, and constraints for a phase of the problem.  <a href="class_open_sim_1_1_moco_phase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_problem.html">MocoProblem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A description of an optimal control problem, backed by OpenSim Models.  <a href="class_open_sim_1_1_moco_problem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_problem_info.html">MocoProblemInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is mostly for internal use for <a class="el" href="class_open_sim_1_1_moco_problem_rep.html" title="The primary intent of this class is for use by MocoSolvers, but users can also use this class to appl...">MocoProblemRep</a> to pass select information about a problem to the <a class="el" href="class_open_sim_1_1_moco_goal.html" title="A goal is term in the cost functional to be minimized, or a set of endpoint constraints that must lie...">MocoGoal</a>s and <a class="el" href="class_open_sim_1_1_moco_path_constraint.html" title="A path constraint to be enforced in the optimal control problem. ">MocoPathConstraint</a>s of the problem during initializeOnModel().  <a href="class_open_sim_1_1_moco_problem_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_problem_rep.html">MocoProblemRep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The primary intent of this class is for use by <a class="el" href="class_open_sim_1_1_moco_solver.html" title="Once the solver is created, you should not make any edits to the MocoProblem. ">MocoSolver</a>s, but users can also use this class to apply parameter values to the model and evaluate cost terms.  <a href="class_open_sim_1_1_moco_problem_rep.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_solution.html">MocoSolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for <a class="el" href="class_open_sim_1_1_moco_study.html#a5e06f6845b114146f051cc34d0f21b1c" title="Solve the provided MocoProblem using the provided MocoSolver, and obtain the solution to the problem...">MocoStudy::solve()</a>.  <a href="class_open_sim_1_1_moco_solution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_solver.html">MocoSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Once the solver is created, you should not make any edits to the <a class="el" href="class_open_sim_1_1_moco_problem.html" title="A description of an optimal control problem, backed by OpenSim Models. ">MocoProblem</a>.  <a href="class_open_sim_1_1_moco_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_state_tracking_goal.html">MocoStateTrackingGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The squared difference between a state variable value and a reference state variable value, summed over the state variables for which a reference is provided, and integrated over the phase.  <a href="class_open_sim_1_1_moco_state_tracking_goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_study.html">MocoStudy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The top-level class for solving a custom optimal control problem.  <a href="class_open_sim_1_1_moco_study.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_sum_squared_state_goal.html">MocoSumSquaredStateGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize the sum of squared states, integrated over the phase.  <a href="class_open_sim_1_1_moco_sum_squared_state_goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_tool.html">MocoTool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a base class for solving problems that depend on an observed motion using Moco's optimal control methods.  <a href="class_open_sim_1_1_moco_tool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_track.html">MocoTrack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><h2><a class="el" href="class_open_sim_1_1_moco_track.html" title="MocoTrack This tool constructs problems in which state and/or marker trajectory data are tracked whil...">MocoTrack</a> </h2>
This tool constructs problems in which state and/or marker trajectory data are tracked while solving for model kinematics and actuator controls.  <a href="class_open_sim_1_1_moco_track.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_trajectory.html">MocoTrajectory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The values of the variables in an optimal control problem.  <a href="class_open_sim_1_1_moco_trajectory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_trajectory_is_sealed.html">MocoTrajectoryIsSealed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception is thrown if you try to invoke most methods on <a class="el" href="class_open_sim_1_1_moco_trajectory.html" title="The values of the variables in an optimal control problem. ">MocoTrajectory</a> while the iterate is sealed.  <a href="class_open_sim_1_1_moco_trajectory_is_sealed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_translation_tracking_goal.html">MocoTranslationTrackingGoal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The squared difference between a model frame's origin position and a reference position value, summed over the frames for which a reference is provided, and integrated over the phase.  <a href="class_open_sim_1_1_moco_translation_tracking_goal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_tropter_solver.html">MocoTropterSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the <a class="el" href="class_open_sim_1_1_moco_problem.html" title="A description of an optimal control problem, backed by OpenSim Models. ">MocoProblem</a> using the <b>tropter</b> direct collocation library.  <a href="class_open_sim_1_1_moco_tropter_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_tropter_solver_not_available.html">MocoTropterSolverNotAvailable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_variable_info.html">MocoVariableInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds on continuous variables (states, controls, multipliers, etc).  <a href="class_open_sim_1_1_moco_variable_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_weight.html">MocoWeight</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains a single property that holds a weighting factor to be used in a <a class="el" href="class_open_sim_1_1_moco_goal.html" title="A goal is term in the cost functional to be minimized, or a set of endpoint constraints that must lie...">MocoGoal</a>.  <a href="class_open_sim_1_1_moco_weight.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_moco_weight_set.html">MocoWeightSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for Moco weights.  <a href="class_open_sim_1_1_moco_weight_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_model_factory.html">ModelFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides utilities for creating <a class="el" href="namespace_open_sim.html" title="The Moco interface is contained within the OpenSim namespace. ">OpenSim</a> models.  <a href="class_open_sim_1_1_model_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_model_operator.html">ModelOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract base class describes <em>any</em> operation that modifies a Model as part of a <a class="el" href="class_open_sim_1_1_model_processor.html" title="This class describes a workflow for processing a Model using ModelOperators. ">ModelProcessor</a>.  <a href="class_open_sim_1_1_model_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_model_processor.html">ModelProcessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes a workflow for processing a Model using <a class="el" href="class_open_sim_1_1_model_operator.html" title="This abstract base class describes any operation that modifies a Model as part of a ModelProcessor...">ModelOperator</a>s.  <a href="class_open_sim_1_1_model_processor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_mod_op_add_external_loads.html">ModOpAddExternalLoads</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add external loads (e.g., ground reaction forces) to the model from a XML file.  <a href="class_open_sim_1_1_mod_op_add_external_loads.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_mod_op_add_reserves.html">ModOpAddReserves</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add reserve actuators to the model using <a class="el" href="class_open_sim_1_1_model_factory.html#a89c02bc5d9722ca220edf8b169e45e30" title="Add CoordinateActuators for each unconstrained coordinate (e.g., ! Coordinate::isConstrained()) in th...">ModelFactory::createReserveActuators</a>.  <a href="class_open_sim_1_1_mod_op_add_reserves.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_mod_op_ignore_activation_dynamics.html">ModOpIgnoreActivationDynamics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn off activation dynamics for all muscles in the model.  <a href="class_open_sim_1_1_mod_op_ignore_activation_dynamics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_mod_op_ignore_passive_fiber_forces_d_g_f.html">ModOpIgnorePassiveFiberForcesDGF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn off passive fiber forces for all <a class="el" href="class_open_sim_1_1_de_groote_fregly2016_muscle.html" title="This muscle model was published in De Groote et al. ">DeGrooteFregly2016Muscle</a>s in the model.  <a href="class_open_sim_1_1_mod_op_ignore_passive_fiber_forces_d_g_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_mod_op_ignore_tendon_compliance.html">ModOpIgnoreTendonCompliance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn off tendon compliance for all muscles in the model.  <a href="class_open_sim_1_1_mod_op_ignore_tendon_compliance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_mod_op_remove_muscles.html">ModOpRemoveMuscles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all muscles contained in the model's ForceSet.  <a href="class_open_sim_1_1_mod_op_remove_muscles.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_mod_op_replace_joints_with_welds.html">ModOpReplaceJointsWithWelds</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_mod_op_replace_muscles_with_de_groote_fregly2016.html">ModOpReplaceMusclesWithDeGrooteFregly2016</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke <a class="el" href="class_open_sim_1_1_de_groote_fregly2016_muscle.html#af728fc5ada2e3813ba150cc127e80805" title="Replace muscles of other types in the model with muscles of this type. ">DeGrooteFregly2016Muscle::replaceMuscles()</a> on the model.  <a href="class_open_sim_1_1_mod_op_replace_muscles_with_de_groote_fregly2016.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_mod_op_scale_active_fiber_force_curve_width_d_g_f.html">ModOpScaleActiveFiberForceCurveWidthDGF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale the active fiber force curve width for all <a class="el" href="class_open_sim_1_1_de_groote_fregly2016_muscle.html" title="This muscle model was published in De Groote et al. ">DeGrooteFregly2016Muscle</a>s in the model.  <a href="class_open_sim_1_1_mod_op_scale_active_fiber_force_curve_width_d_g_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_mod_op_scale_max_isometric_force.html">ModOpScaleMaxIsometricForce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale the max isometric force for all muscles in the model.  <a href="class_open_sim_1_1_mod_op_scale_max_isometric_force.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_mod_op_set_path_length_approximation.html">ModOpSetPathLengthApproximation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn on or off path length approximation for all GeometryPath components in the model.  <a href="class_open_sim_1_1_mod_op_set_path_length_approximation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_mod_op_tendon_compliance_dynamics_mode_d_g_f.html">ModOpTendonComplianceDynamicsModeDGF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <a class="el" href="class_open_sim_1_1_de_groote_fregly2016_muscle.html" title="This muscle model was published in De Groote et al. ">DeGrooteFregly2016Muscle</a> muscles whose 'ignore_tendon_compliance' property is false, set the tendon compliance dynamics mode to either 'explicit' or 'implicit'.  <a href="class_open_sim_1_1_mod_op_tendon_compliance_dynamics_mode_d_g_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_mod_op_use_implicit_tendon_compliance_dynamics_d_g_f.html">ModOpUseImplicitTendonComplianceDynamicsDGF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn off passive fiber forces for all <a class="el" href="class_open_sim_1_1_de_groote_fregly2016_muscle.html" title="This muscle model was published in De Groote et al. ">DeGrooteFregly2016Muscle</a>s in the model.  <a href="class_open_sim_1_1_mod_op_use_implicit_tendon_compliance_dynamics_d_g_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_multivariate_polynomial_function.html">MultivariatePolynomialFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_position_motion.html">PositionMotion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class prescribes the value, speed, and acceleration of all coordinates in the model using SimTK::Motion.  <a href="class_open_sim_1_1_position_motion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_sim_t_k_multivariate_polynomial.html">SimTKMultivariatePolynomial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_smooth_sphere_half_space_force.html">SmoothSphereHalfSpaceForce</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_station_plane_contact_force.html">StationPlaneContactForce</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class models compliant point contact with a ground plane y=0.  <a href="class_open_sim_1_1_station_plane_contact_force.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_stopwatch.html">Stopwatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record and report elapsed real time ("clock" or "wall" time) in seconds.  <a href="class_open_sim_1_1_stopwatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_stream_format.html">StreamFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class stores the formatting of a stream and restores that format when the <a class="el" href="class_open_sim_1_1_stream_format.html" title="This class stores the formatting of a stream and restores that format when the StreamFormat is destru...">StreamFormat</a> is destructed.  <a href="class_open_sim_1_1_stream_format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_table_operator.html">TableOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class describes <em>any</em> operation that consumes a modifies a TimeSeriesTable as part of a <a class="el" href="class_open_sim_1_1_table_processor.html" title="This class describes a workflow for processing a table using TableOperators. ">TableProcessor</a>.  <a href="class_open_sim_1_1_table_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_table_processor.html">TableProcessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes a workflow for processing a table using <a class="el" href="class_open_sim_1_1_table_operator.html" title="This abstract class describes any operation that consumes a modifies a TimeSeriesTable as part of a T...">TableOperator</a>s.  <a href="class_open_sim_1_1_table_processor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_tab_op_low_pass_filter.html">TabOpLowPassFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a low-pass filter to the trajectory.  <a href="class_open_sim_1_1_tab_op_low_pass_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_tab_op_use_absolute_state_names.html">TabOpUseAbsoluteStateNames</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update table column labels to use post-4.0 state paths instead of pre-4.0 state names.  <a href="class_open_sim_1_1_tab_op_use_absolute_state_names.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_sim_1_1_threadsafe_jar.html">ThreadsafeJar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class lets you store objects of a single type for reuse by multiple threads, ensuring threadsafe access to each of those objects.  <a href="class_open_sim_1_1_threadsafe_jar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a398ff013519340e9eed080f5bb5566cd"><td class="memItemLeft" align="right" valign="top"><a id="a398ff013519340e9eed080f5bb5566cd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VectorDM</b> = std::vector&lt; casadi::DM &gt;</td></tr>
<tr class="separator:a398ff013519340e9eed080f5bb5566cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4286a47452ef915e89270cee497faaec"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a4286a47452ef915e89270cee497faaec">KinematicLevel</a> { <br />
&#160;&#160;<b>Position</b>, 
<b>DtPosition</b>, 
<b>Velocity</b>, 
<b>DtDtPosition</b>, 
<br />
&#160;&#160;<b>DtVelocity</b>, 
<b>Acceleration</b>
<br />
 }</td></tr>
<tr class="memdesc:a4286a47452ef915e89270cee497faaec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kinematic level for a scalar kinematic constraint within a MocoKinematicConstraint.  <a href="namespace_open_sim.html#a4286a47452ef915e89270cee497faaec">More...</a><br /></td></tr>
<tr class="separator:a4286a47452ef915e89270cee497faaec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a748afb2805b5e6f5a04e0c49c348a2bf"><td class="memItemLeft" align="right" valign="top"><a id="a748afb2805b5e6f5a04e0c49c348a2bf"></a>
OSIMMOCO_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>GetMocoVersionAndDate</b> ()</td></tr>
<tr class="separator:a748afb2805b5e6f5a04e0c49c348a2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f13cf3e97877bbc8c8e368d470a4eb0"><td class="memItemLeft" align="right" valign="top"><a id="a4f13cf3e97877bbc8c8e368d470a4eb0"></a>
OSIMMOCO_API std::string&#160;</td><td class="memItemRight" valign="bottom"><b>GetMocoVersion</b> ()</td></tr>
<tr class="separator:a4f13cf3e97877bbc8c8e368d470a4eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f93b43c9a582ae34ce336fb1fe85d6"><td class="memItemLeft" align="right" valign="top"><a id="a13f93b43c9a582ae34ce336fb1fe85d6"></a>
<a class="el" href="struct_cas_o_c_1_1_bounds.html">CasOC::Bounds</a>&#160;</td><td class="memItemRight" valign="bottom"><b>convertBounds</b> (const <a class="el" href="class_open_sim_1_1_moco_bounds.html">MocoBounds</a> &amp;mb)</td></tr>
<tr class="separator:a13f93b43c9a582ae34ce336fb1fe85d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3eb047aa3039e12ad31479d5dbd4819"><td class="memItemLeft" align="right" valign="top"><a id="ad3eb047aa3039e12ad31479d5dbd4819"></a>
<a class="el" href="struct_cas_o_c_1_1_bounds.html">CasOC::Bounds</a>&#160;</td><td class="memItemRight" valign="bottom"><b>convertBounds</b> (const <a class="el" href="class_open_sim_1_1_moco_initial_bounds.html">MocoInitialBounds</a> &amp;mb)</td></tr>
<tr class="separator:ad3eb047aa3039e12ad31479d5dbd4819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f4c7d23a0dce2c4fec4e1494648f58"><td class="memItemLeft" align="right" valign="top"><a id="a91f4c7d23a0dce2c4fec4e1494648f58"></a>
<a class="el" href="struct_cas_o_c_1_1_bounds.html">CasOC::Bounds</a>&#160;</td><td class="memItemRight" valign="bottom"><b>convertBounds</b> (const <a class="el" href="class_open_sim_1_1_moco_final_bounds.html">MocoFinalBounds</a> &amp;mb)</td></tr>
<tr class="separator:a91f4c7d23a0dce2c4fec4e1494648f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796a5573814872a863a4b93ca4ad3138"><td class="memItemLeft" align="right" valign="top">casadi::DM&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a796a5573814872a863a4b93ca4ad3138">convertToCasADiDMTranspose</a> (const SimTK::Matrix &amp;simtkMatrix)</td></tr>
<tr class="memdesc:a796a5573814872a863a4b93ca4ad3138"><td class="mdescLeft">&#160;</td><td class="mdescRight">This converts a SimTK::Matrix to a casadi::DM matrix, transposing the data in the process.  <a href="#a796a5573814872a863a4b93ca4ad3138">More...</a><br /></td></tr>
<tr class="separator:a796a5573814872a863a4b93ca4ad3138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be46b2b2c5af407d9b222d807c57c01"><td class="memTemplParams" colspan="2"><a id="a8be46b2b2c5af407d9b222d807c57c01"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8be46b2b2c5af407d9b222d807c57c01"><td class="memTemplItemLeft" align="right" valign="top">casadi::DM&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertToCasADiDMTemplate</b> (const T &amp;simtk)</td></tr>
<tr class="separator:a8be46b2b2c5af407d9b222d807c57c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804073cb4313164409449e87d46a0715"><td class="memItemLeft" align="right" valign="top"><a id="a804073cb4313164409449e87d46a0715"></a>
casadi::DM&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a804073cb4313164409449e87d46a0715">convertToCasADiDMTranspose</a> (const SimTK::RowVector &amp;simtkRV)</td></tr>
<tr class="memdesc:a804073cb4313164409449e87d46a0715"><td class="mdescLeft">&#160;</td><td class="mdescRight">This converts a SimTK::RowVector to a casadi::DM column vector. <br /></td></tr>
<tr class="separator:a804073cb4313164409449e87d46a0715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a66393534590f7e0d86251fb69909a7"><td class="memItemLeft" align="right" valign="top"><a id="a6a66393534590f7e0d86251fb69909a7"></a>
casadi::DM&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a6a66393534590f7e0d86251fb69909a7">convertToCasADiDM</a> (const SimTK::Vector &amp;simtkVec)</td></tr>
<tr class="memdesc:a6a66393534590f7e0d86251fb69909a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This converts a SimTK::Vector to a casadi::DM column vector. <br /></td></tr>
<tr class="separator:a6a66393534590f7e0d86251fb69909a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8198b69505fb2f3eee1f1c0077f471d2"><td class="memItemLeft" align="right" valign="top"><a id="a8198b69505fb2f3eee1f1c0077f471d2"></a>
<a class="el" href="struct_cas_o_c_1_1_iterate.html">CasOC::Iterate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a8198b69505fb2f3eee1f1c0077f471d2">convertToCasOCIterate</a> (const <a class="el" href="class_open_sim_1_1_moco_trajectory.html">MocoTrajectory</a> &amp;mocoIt)</td></tr>
<tr class="memdesc:a8198b69505fb2f3eee1f1c0077f471d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This resamples the iterate to obtain values that lie on the mesh. <br /></td></tr>
<tr class="separator:a8198b69505fb2f3eee1f1c0077f471d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6570743af7c47aa41ba3aee170405e1c"><td class="memTemplParams" colspan="2"><a id="a6570743af7c47aa41ba3aee170405e1c"></a>
template&lt;typename VectorType  = SimTK::Vector&gt; </td></tr>
<tr class="memitem:a6570743af7c47aa41ba3aee170405e1c"><td class="memTemplItemLeft" align="right" valign="top">VectorType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertToSimTKVector</b> (const casadi::DM &amp;casVector)</td></tr>
<tr class="separator:a6570743af7c47aa41ba3aee170405e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fa83db4b660907c92fda46af34e035"><td class="memItemLeft" align="right" valign="top">SimTK::Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a50fa83db4b660907c92fda46af34e035">convertToSimTKMatrix</a> (const casadi::DM &amp;casMatrix)</td></tr>
<tr class="memdesc:a50fa83db4b660907c92fda46af34e035"><td class="mdescLeft">&#160;</td><td class="mdescRight">This converts a casadi::DM matrix to a SimTK::Matrix, transposing the data in the process.  <a href="#a50fa83db4b660907c92fda46af34e035">More...</a><br /></td></tr>
<tr class="separator:a50fa83db4b660907c92fda46af34e035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae363644cb4cae8e189d659fe266d172a"><td class="memTemplParams" colspan="2"><a id="ae363644cb4cae8e189d659fe266d172a"></a>
template&lt;typename TOut  = MocoTrajectory&gt; </td></tr>
<tr class="memitem:ae363644cb4cae8e189d659fe266d172a"><td class="memTemplItemLeft" align="right" valign="top">TOut&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertToMocoTrajectory</b> (const <a class="el" href="struct_cas_o_c_1_1_iterate.html">CasOC::Iterate</a> &amp;casIt)</td></tr>
<tr class="separator:ae363644cb4cae8e189d659fe266d172a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa258d8737b024554c06553d1d88266c0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:aa258d8737b024554c06553d1d88266c0"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#aa258d8737b024554c06553d1d88266c0">make_unique</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa258d8737b024554c06553d1d88266c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since Moco does not require C++14 (which contains std::make_unique()), here is an implementation of <a class="el" href="namespace_open_sim.html#aa258d8737b024554c06553d1d88266c0" title="Since Moco does not require C++14 (which contains std::make_unique()), here is an implementation of m...">make_unique()</a>.  <a href="#aa258d8737b024554c06553d1d88266c0">More...</a><br /></td></tr>
<tr class="separator:aa258d8737b024554c06553d1d88266c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3c0fe4e0f827309f2791244625748f"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a2e3c0fe4e0f827309f2791244625748f">getFormattedDateTime</a> (bool appendMicroseconds=false, std::string <a class="el" href="namespace_open_sim.html#a8ff3b037274379f4f31742a6db884400">format</a>=&quot;%Y-%m-%dT%H%M%S&quot;)</td></tr>
<tr class="memdesc:a2e3c0fe4e0f827309f2791244625748f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a string with the current date and time formatted as Y-m-dTHMS (year, month, day, "T", hour, minute, second).  <a href="#a2e3c0fe4e0f827309f2791244625748f">More...</a><br /></td></tr>
<tr class="separator:a2e3c0fe4e0f827309f2791244625748f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ee1403ee61601cddc37f587774b944"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#ac0ee1403ee61601cddc37f587774b944">startsWith</a> (const std::string &amp;string, const std::string &amp;start)</td></tr>
<tr class="memdesc:ac0ee1403ee61601cddc37f587774b944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if <code>string</code> starts with the substring <code>start</code>.  <a href="#ac0ee1403ee61601cddc37f587774b944">More...</a><br /></td></tr>
<tr class="separator:ac0ee1403ee61601cddc37f587774b944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97903aa67e0c6d46260d745c197c2a25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a97903aa67e0c6d46260d745c197c2a25">endsWith</a> (const std::string &amp;string, const std::string &amp;ending)</td></tr>
<tr class="memdesc:a97903aa67e0c6d46260d745c197c2a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if <code>string</code> ends with the substring <code>ending</code>.  <a href="#a97903aa67e0c6d46260d745c197c2a25">More...</a><br /></td></tr>
<tr class="separator:a97903aa67e0c6d46260d745c197c2a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96caa7cc52282d844d48bc3314d17384"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API SimTK::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a96caa7cc52282d844d48bc3314d17384">createVectorLinspace</a> (int length, double start, double end)</td></tr>
<tr class="memdesc:a96caa7cc52282d844d48bc3314d17384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a SimTK::Vector with the provided length whose elements are linearly spaced between start and end.  <a href="#a96caa7cc52282d844d48bc3314d17384">More...</a><br /></td></tr>
<tr class="separator:a96caa7cc52282d844d48bc3314d17384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34a476e3e6f7f42d6d15a6222a8a9d5"><td class="memItemLeft" align="right" valign="top"><a id="af34a476e3e6f7f42d6d15a6222a8a9d5"></a>
OSIMMOCO_API SimTK::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#af34a476e3e6f7f42d6d15a6222a8a9d5">createVector</a> (std::initializer_list&lt; SimTK::Real &gt; elements)</td></tr>
<tr class="memdesc:af34a476e3e6f7f42d6d15a6222a8a9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a SimTK::Vector using modern C++ syntax. <br /></td></tr>
<tr class="separator:af34a476e3e6f7f42d6d15a6222a8a9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c339028de63cc21e485c9c13661717"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API SimTK::Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a26c339028de63cc21e485c9c13661717">interpolate</a> (const SimTK::Vector &amp;x, const SimTK::Vector &amp;y, const SimTK::Vector &amp;newX, const bool ignoreNaNs=false)</td></tr>
<tr class="memdesc:a26c339028de63cc21e485c9c13661717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearly interpolate y(x) at new values of x.  <a href="#a26c339028de63cc21e485c9c13661717">More...</a><br /></td></tr>
<tr class="separator:a26c339028de63cc21e485c9c13661717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac790678acb1e3333fccc14e2f65af1d"><td class="memTemplParams" colspan="2"><a id="aac790678acb1e3333fccc14e2f65af1d"></a>
template&lt;typename FunctionType &gt; </td></tr>
<tr class="memitem:aac790678acb1e3333fccc14e2f65af1d"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; FunctionSet &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createFunctionSet</b> (const TimeSeriesTable &amp;table)</td></tr>
<tr class="separator:aac790678acb1e3333fccc14e2f65af1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab11884559d25f9febdcdd843d9a803"><td class="memTemplParams" colspan="2"><a id="afab11884559d25f9febdcdd843d9a803"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:afab11884559d25f9febdcdd843d9a803"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; FunctionSet &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createFunctionSet&lt; GCVSpline &gt;</b> (const TimeSeriesTable &amp;table)</td></tr>
<tr class="separator:afab11884559d25f9febdcdd843d9a803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad599297239897b686094535fa0d26710"><td class="memTemplParams" colspan="2">template&lt;typename TimeVector , typename FunctionType  = GCVSpline&gt; </td></tr>
<tr class="memitem:ad599297239897b686094535fa0d26710"><td class="memTemplItemLeft" align="right" valign="top">TimeSeriesTable&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#ad599297239897b686094535fa0d26710">resample</a> (const TimeSeriesTable &amp;in, const TimeVector &amp;newTime)</td></tr>
<tr class="memdesc:ad599297239897b686094535fa0d26710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resample (interpolate) the table at the provided times.  <a href="#ad599297239897b686094535fa0d26710">More...</a><br /></td></tr>
<tr class="separator:ad599297239897b686094535fa0d26710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f73e666ec1c1f00fb25fbc94a95747"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API Storage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a87f73e666ec1c1f00fb25fbc94a95747">convertTableToStorage</a> (const TimeSeriesTable &amp;)</td></tr>
<tr class="memdesc:a87f73e666ec1c1f00fb25fbc94a95747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Storage from a TimeSeriesTable.  <a href="#a87f73e666ec1c1f00fb25fbc94a95747">More...</a><br /></td></tr>
<tr class="separator:a87f73e666ec1c1f00fb25fbc94a95747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e631879e9d2a6d101b4f5014baafb4"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API TimeSeriesTable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#ab2e631879e9d2a6d101b4f5014baafb4">filterLowpass</a> (const TimeSeriesTable &amp;table, double cutoffFreq, bool padData=false)</td></tr>
<tr class="memdesc:ab2e631879e9d2a6d101b4f5014baafb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowpass filter the data in a TimeSeriesTable at a provided cutoff frequency.  <a href="#ab2e631879e9d2a6d101b4f5014baafb4">More...</a><br /></td></tr>
<tr class="separator:ab2e631879e9d2a6d101b4f5014baafb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab924a2cbfe8ab4871b9035e8b1c8fe90"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab924a2cbfe8ab4871b9035e8b1c8fe90"><td class="memTemplItemLeft" align="right" valign="top">TimeSeriesTable_&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#ab924a2cbfe8ab4871b9035e8b1c8fe90">readTableFromFileT</a> (const std::string &amp;filepath)</td></tr>
<tr class="memdesc:ab924a2cbfe8ab4871b9035e8b1c8fe90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a table of type TimeSeriesTable_&lt;T&gt; from file, where T is the type of the elements contained in the table's columns.  <a href="#ab924a2cbfe8ab4871b9035e8b1c8fe90">More...</a><br /></td></tr>
<tr class="separator:ab924a2cbfe8ab4871b9035e8b1c8fe90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4145605aed5f3127a9a7f072c2c34957"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API TimeSeriesTable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a4145605aed5f3127a9a7f072c2c34957">readTableFromFile</a> (const std::string &amp;filepath)</td></tr>
<tr class="memdesc:a4145605aed5f3127a9a7f072c2c34957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a TimeSeriesTable from file containing scalar elements.  <a href="#a4145605aed5f3127a9a7f072c2c34957">More...</a><br /></td></tr>
<tr class="separator:a4145605aed5f3127a9a7f072c2c34957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f397045aff484c51aae9aebcbbba9a1"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a8f397045aff484c51aae9aebcbbba9a1">writeTableToFile</a> (const TimeSeriesTable &amp;, const std::string &amp;)</td></tr>
<tr class="memdesc:a8f397045aff484c51aae9aebcbbba9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single TimeSeriesTable to a file, using the FileAdapter associated with the provided file extension.  <a href="#a8f397045aff484c51aae9aebcbbba9a1">More...</a><br /></td></tr>
<tr class="separator:a8f397045aff484c51aae9aebcbbba9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2088a2424cbb90feb91a326d047adcbb"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a2088a2424cbb90feb91a326d047adcbb">visualize</a> (Model, Storage)</td></tr>
<tr class="memdesc:a2088a2424cbb90feb91a326d047adcbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Play back a motion (from the Storage) in the simbody-visuailzer.  <a href="#a2088a2424cbb90feb91a326d047adcbb">More...</a><br /></td></tr>
<tr class="separator:a2088a2424cbb90feb91a326d047adcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0b10825c2e3cbf07a35110f81f11b9"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a3b0b10825c2e3cbf07a35110f81f11b9">visualize</a> (Model, TimeSeriesTable)</td></tr>
<tr class="memdesc:a3b0b10825c2e3cbf07a35110f81f11b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the same as <a class="el" href="namespace_open_sim.html#a2088a2424cbb90feb91a326d047adcbb" title="Play back a motion (from the Storage) in the simbody-visuailzer. ">visualize(Model, Storage)</a>, except that the states are provided in a TimeSeriesTable.  <a href="#a3b0b10825c2e3cbf07a35110f81f11b9">More...</a><br /></td></tr>
<tr class="separator:a3b0b10825c2e3cbf07a35110f81f11b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6388a79ad2fa3f117f9e7ecb1e6d8877"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6388a79ad2fa3f117f9e7ecb1e6d8877"><td class="memTemplItemLeft" align="right" valign="top">TimeSeriesTable_&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a6388a79ad2fa3f117f9e7ecb1e6d8877">analyze</a> (Model model, const <a class="el" href="class_open_sim_1_1_moco_trajectory.html">MocoTrajectory</a> &amp;iterate, std::vector&lt; std::string &gt; outputPaths)</td></tr>
<tr class="memdesc:a6388a79ad2fa3f117f9e7ecb1e6d8877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the requested outputs using the model in the problem and the states and controls in the <a class="el" href="class_open_sim_1_1_moco_trajectory.html" title="The values of the variables in an optimal control problem. ">MocoTrajectory</a>.  <a href="#a6388a79ad2fa3f117f9e7ecb1e6d8877">More...</a><br /></td></tr>
<tr class="separator:a6388a79ad2fa3f117f9e7ecb1e6d8877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34b095dbdeec386fa965d3110232f58"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#ac34b095dbdeec386fa965d3110232f58">prescribeControlsToModel</a> (const <a class="el" href="class_open_sim_1_1_moco_trajectory.html">MocoTrajectory</a> &amp;iterate, Model &amp;model, std::string functionType=&quot;GCVSpline&quot;)</td></tr>
<tr class="memdesc:ac34b095dbdeec386fa965d3110232f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <a class="el" href="class_open_sim_1_1_moco_trajectory.html" title="The values of the variables in an optimal control problem. ">MocoTrajectory</a> and the associated <a class="el" href="namespace_open_sim.html" title="The Moco interface is contained within the OpenSim namespace. ">OpenSim</a> model, return the model with a prescribed controller appended that will compute the control values from the <a class="el" href="class_open_sim_1_1_moco_solution.html" title="Return type for MocoStudy::solve(). ">MocoSolution</a>.  <a href="#ac34b095dbdeec386fa965d3110232f58">More...</a><br /></td></tr>
<tr class="separator:ac34b095dbdeec386fa965d3110232f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a21b59cf52c31b06f9037305535827d"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API <a class="el" href="class_open_sim_1_1_moco_trajectory.html">MocoTrajectory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a3a21b59cf52c31b06f9037305535827d">simulateIterateWithTimeStepping</a> (const <a class="el" href="class_open_sim_1_1_moco_trajectory.html">MocoTrajectory</a> &amp;iterate, Model model, double integratorAccuracy=-1)</td></tr>
<tr class="memdesc:a3a21b59cf52c31b06f9037305535827d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the controls and initial state in the provided iterate to simulate the model using an ODE time stepping integrator (OpenSim::Manager), and return the resulting states and controls.  <a href="#a3a21b59cf52c31b06f9037305535827d">More...</a><br /></td></tr>
<tr class="separator:a3a21b59cf52c31b06f9037305535827d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1045cb61806f23d170ebf40a1b107ee3"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a1045cb61806f23d170ebf40a1b107ee3">createStateVariableNamesInSystemOrder</a> (const Model &amp;model)</td></tr>
<tr class="memdesc:a1045cb61806f23d170ebf40a1b107ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The map provides the index of each state variable in SimTK::State::getY() from its each state variable path string.  <a href="#a1045cb61806f23d170ebf40a1b107ee3">More...</a><br /></td></tr>
<tr class="separator:a1045cb61806f23d170ebf40a1b107ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab870f25b5f946f89a5df60dcb6117665"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#ab870f25b5f946f89a5df60dcb6117665">createStateVariableNamesInSystemOrder</a> (const Model &amp;model, std::unordered_map&lt; int, int &gt; &amp;yIndexMap)</td></tr>
<tr class="memdesc:ab870f25b5f946f89a5df60dcb6117665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but you can obtain a map from the returned state variable names to the index in SimTK::State::getY() that accounts for empty slots in Y.  <a href="#ab870f25b5f946f89a5df60dcb6117665">More...</a><br /></td></tr>
<tr class="separator:ab870f25b5f946f89a5df60dcb6117665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada21b7233f4d453b13086612c60cbe36"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API std::unordered_map&lt; std::string, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#ada21b7233f4d453b13086612c60cbe36">createSystemYIndexMap</a> (const Model &amp;model)</td></tr>
<tr class="memdesc:ada21b7233f4d453b13086612c60cbe36"><td class="mdescLeft">&#160;</td><td class="mdescRight">The map provides the index of each state variable in SimTK::State::getY() from its state variable path string.  <a href="#ada21b7233f4d453b13086612c60cbe36">More...</a><br /></td></tr>
<tr class="separator:ada21b7233f4d453b13086612c60cbe36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1a9aa9f611068ee70b20792b9a44de"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a4b1a9aa9f611068ee70b20792b9a44de">createControlNamesFromModel</a> (const Model &amp;model, std::vector&lt; int &gt; &amp;modelControlIndices)</td></tr>
<tr class="memdesc:a4b1a9aa9f611068ee70b20792b9a44de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vector of control names based on the actuators in the model for which appliesForce == True.  <a href="#a4b1a9aa9f611068ee70b20792b9a44de">More...</a><br /></td></tr>
<tr class="separator:a4b1a9aa9f611068ee70b20792b9a44de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c3e113418859a47b7487ad742784f9"><td class="memItemLeft" align="right" valign="top"><a id="a96c3e113418859a47b7487ad742784f9"></a>
OSIMMOCO_API std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a96c3e113418859a47b7487ad742784f9">createControlNamesFromModel</a> (const Model &amp;model)</td></tr>
<tr class="memdesc:a96c3e113418859a47b7487ad742784f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but when there is no mapping to the modelControlIndices. <br /></td></tr>
<tr class="separator:a96c3e113418859a47b7487ad742784f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8f02f12bea688291032dbe052311d6"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API std::unordered_map&lt; std::string, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a3b8f02f12bea688291032dbe052311d6">createSystemControlIndexMap</a> (const Model &amp;model)</td></tr>
<tr class="memdesc:a3b8f02f12bea688291032dbe052311d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The map provides the index of each control variable in the SimTK::Vector return by OpenSim::Model::getControls() from its control name.  <a href="#a3b8f02f12bea688291032dbe052311d6">More...</a><br /></td></tr>
<tr class="separator:a3b8f02f12bea688291032dbe052311d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab813e9a3a814e117d7e7f5796a36518e"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#ab813e9a3a814e117d7e7f5796a36518e">checkOrderSystemControls</a> (const Model &amp;model)</td></tr>
<tr class="memdesc:ab813e9a3a814e117d7e7f5796a36518e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws an exception if the order of the controls in the model is not the same as the order of the actuators in the model.  <a href="#ab813e9a3a814e117d7e7f5796a36518e">More...</a><br /></td></tr>
<tr class="separator:ab813e9a3a814e117d7e7f5796a36518e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e9a2727738c7f770c3797230653077"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#ab7e9a2727738c7f770c3797230653077">checkRedundantLabels</a> (std::vector&lt; std::string &gt; labels)</td></tr>
<tr class="memdesc:ab7e9a2727738c7f770c3797230653077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws an exception if the same label appears twice in the list of labels.  <a href="#ab7e9a2727738c7f770c3797230653077">More...</a><br /></td></tr>
<tr class="separator:ab7e9a2727738c7f770c3797230653077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2651693a131d710ec2775c3b8ec03f3"><td class="memTemplParams" colspan="2">template&lt;typename T  = double&gt; </td></tr>
<tr class="memitem:ac2651693a131d710ec2775c3b8ec03f3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; SimTK::ReferencePtr&lt; const Output&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#ac2651693a131d710ec2775c3b8ec03f3">getModelOutputReferencePtrs</a> (const Component &amp;component, const std::string &amp;pattern, bool includeDescendents=false)</td></tr>
<tr class="memdesc:ac2651693a131d710ec2775c3b8ec03f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of reference pointers to all outputs whose names (not paths) match a substring defined by a provided regex string pattern.  <a href="#ac2651693a131d710ec2775c3b8ec03f3">More...</a><br /></td></tr>
<tr class="separator:ac2651693a131d710ec2775c3b8ec03f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bec286246ccd6fc9ba385ba2b97957"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API <a class="el" href="class_open_sim_1_1_moco_trajectory.html">MocoTrajectory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a70bec286246ccd6fc9ba385ba2b97957">createPeriodicTrajectory</a> (const <a class="el" href="class_open_sim_1_1_moco_trajectory.html">MocoTrajectory</a> &amp;halfPeriodTrajectory, std::vector&lt; std::string &gt; addPatterns={&quot;.*pelvis_tx/value&quot;}, std::vector&lt; std::string &gt; negatePatterns={&quot;.*pelvis_list.*&quot;, &quot;.*pelvis_rotation.*&quot;, &quot;.*pelvis_tz.*&quot;}, std::vector&lt; std::pair&lt; std::string, std::string &gt;&gt; symmetryPatterns={{R&quot;(_r(\$))&quot;, &quot;_l$1&quot;}, {R&quot;(_l(\$))&quot;, &quot;_r$1&quot;}})</td></tr>
<tr class="memdesc:a70bec286246ccd6fc9ba385ba2b97957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a trajectory covering half the period of a symmetric motion into a trajectory over the full period.  <a href="#a70bec286246ccd6fc9ba385ba2b97957">More...</a><br /></td></tr>
<tr class="separator:a70bec286246ccd6fc9ba385ba2b97957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea72d92099e28d9cb83b4049cec8beea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea72d92099e28d9cb83b4049cec8beea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#aea72d92099e28d9cb83b4049cec8beea">checkPropertyInSet</a> (const Object &amp;obj, const Property&lt; T &gt; &amp;p, const std::set&lt; T &gt; &amp;set)</td></tr>
<tr class="memdesc:aea72d92099e28d9cb83b4049cec8beea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the property's value is not in the provided set.  <a href="#aea72d92099e28d9cb83b4049cec8beea">More...</a><br /></td></tr>
<tr class="separator:aea72d92099e28d9cb83b4049cec8beea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929e22e5913ca94fe8b9cfd6ec36dd27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a929e22e5913ca94fe8b9cfd6ec36dd27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a929e22e5913ca94fe8b9cfd6ec36dd27">checkPropertyIsPositive</a> (const Object &amp;obj, const Property&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a929e22e5913ca94fe8b9cfd6ec36dd27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the property's value is not positive.  <a href="#a929e22e5913ca94fe8b9cfd6ec36dd27">More...</a><br /></td></tr>
<tr class="separator:a929e22e5913ca94fe8b9cfd6ec36dd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf40fff82cb030c5eeb3ff614f016ee7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf40fff82cb030c5eeb3ff614f016ee7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#abf40fff82cb030c5eeb3ff614f016ee7">checkPropertyInRangeOrSet</a> (const Object &amp;obj, const Property&lt; T &gt; &amp;p, const T &amp;lower, const T &amp;upper, const std::set&lt; T &gt; &amp;set)</td></tr>
<tr class="memdesc:abf40fff82cb030c5eeb3ff614f016ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the property's value is neither in the provided range nor in the provided set.  <a href="#abf40fff82cb030c5eeb3ff614f016ee7">More...</a><br /></td></tr>
<tr class="separator:abf40fff82cb030c5eeb3ff614f016ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ea0f4e9e9582c60e5dfba9c10254fe"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a30ea0f4e9e9582c60e5dfba9c10254fe">getMocoParallelEnvironmentVariable</a> ()</td></tr>
<tr class="memdesc:a30ea0f4e9e9582c60e5dfba9c10254fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This obtains the value of the OPENSIM_MOCO_PARALLEL environment variable.  <a href="#a30ea0f4e9e9582c60e5dfba9c10254fe">More...</a><br /></td></tr>
<tr class="separator:a30ea0f4e9e9582c60e5dfba9c10254fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c0e6712096b1eaabe50514204d8c9f"><td class="memItemLeft" align="right" valign="top">OSIMMOCO_API TimeSeriesTable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a66c0e6712096b1eaabe50514204d8c9f">createExternalLoadsTableForGait</a> (Model model, const <a class="el" href="class_open_sim_1_1_moco_trajectory.html">MocoTrajectory</a> &amp;trajectory, const std::vector&lt; std::string &gt; &amp;forceNamesRightFoot, const std::vector&lt; std::string &gt; &amp;forceNamesLeftFoot)</td></tr>
<tr class="memdesc:a66c0e6712096b1eaabe50514204d8c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the ground reaction forces, centers of pressure, and torques resulting from Force elements (e.g., <a class="el" href="class_open_sim_1_1_smooth_sphere_half_space_force.html">SmoothSphereHalfSpaceForce</a>), using the model and the trajectory.  <a href="#a66c0e6712096b1eaabe50514204d8c9f">More...</a><br /></td></tr>
<tr class="separator:a66c0e6712096b1eaabe50514204d8c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Filling in a string with variables.</div></td></tr>
<tr class="memitem:a3d3c4fa14d4de297beb390cadb031ad4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d3c4fa14d4de297beb390cadb031ad4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_open_sim_1_1make__printable__return.html">make_printable_return</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a3d3c4fa14d4de297beb390cadb031ad4">make_printable</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a3d3c4fa14d4de297beb390cadb031ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to types that can be printed with sprintf() (vsnprintf()).  <a href="#a3d3c4fa14d4de297beb390cadb031ad4">More...</a><br /></td></tr>
<tr class="separator:a3d3c4fa14d4de297beb390cadb031ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca99fc8825bba4b35337dea977da0c51"><td class="memTemplParams" colspan="2"><a id="aca99fc8825bba4b35337dea977da0c51"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aca99fc8825bba4b35337dea977da0c51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_open_sim_1_1make__printable__return.html">make_printable_return</a>&lt; std::string &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#aca99fc8825bba4b35337dea977da0c51">make_printable</a> (const std::string &amp;x)</td></tr>
<tr class="memdesc:aca99fc8825bba4b35337dea977da0c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for std::string. <br /></td></tr>
<tr class="separator:aca99fc8825bba4b35337dea977da0c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6728b41ec3b40c046f8cb97f5821f67"><td class="memItemLeft" align="right" valign="top"><a id="ab6728b41ec3b40c046f8cb97f5821f67"></a>
OSIMMOCO_API std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#ab6728b41ec3b40c046f8cb97f5821f67">format_c</a> (const char *,...)</td></tr>
<tr class="memdesc:ab6728b41ec3b40c046f8cb97f5821f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a char array using (C interface; mainly for internal use). <br /></td></tr>
<tr class="separator:ab6728b41ec3b40c046f8cb97f5821f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff3b037274379f4f31742a6db884400"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a8ff3b037274379f4f31742a6db884400"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a8ff3b037274379f4f31742a6db884400">format</a> (const std::string &amp;formatString, Types... args)</td></tr>
<tr class="memdesc:a8ff3b037274379f4f31742a6db884400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a string in the style of sprintf.  <a href="#a8ff3b037274379f4f31742a6db884400">More...</a><br /></td></tr>
<tr class="separator:a8ff3b037274379f4f31742a6db884400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ef06878f1f7f264543d89805c1cd6b"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a56ef06878f1f7f264543d89805c1cd6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_sim.html#a56ef06878f1f7f264543d89805c1cd6b">printMessage</a> (const std::string &amp;formatString, Types... args)</td></tr>
<tr class="memdesc:a56ef06878f1f7f264543d89805c1cd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a formatted string to std::cout.  <a href="#a56ef06878f1f7f264543d89805c1cd6b">More...</a><br /></td></tr>
<tr class="separator:a56ef06878f1f7f264543d89805c1cd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Moco interface is contained within the <a class="el" href="namespace_open_sim.html" title="The Moco interface is contained within the OpenSim namespace. ">OpenSim</a> namespace. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a4286a47452ef915e89270cee497faaec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4286a47452ef915e89270cee497faaec">&#9670;&nbsp;</a></span>KinematicLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_open_sim.html#a4286a47452ef915e89270cee497faaec">OpenSim::KinematicLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The kinematic level for a scalar kinematic constraint within a <a class="el" href="class_open_sim_1_1_moco_kinematic_constraint.html" title="A model kinematic constraint to be enforced in the optimal control problem. ">MocoKinematicConstraint</a>. </p>
<p>Each scalar constraint is automatically assigned a KinematicLevel enum value when a <a class="el" href="class_open_sim_1_1_moco_kinematic_constraint.html" title="A model kinematic constraint to be enforced in the optimal control problem. ">MocoKinematicConstraint</a> is instantiated. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6388a79ad2fa3f117f9e7ecb1e6d8877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6388a79ad2fa3f117f9e7ecb1e6d8877">&#9670;&nbsp;</a></span>analyze()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TimeSeriesTable_&lt;T&gt; OpenSim::analyze </td>
          <td>(</td>
          <td class="paramtype">Model&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_open_sim_1_1_moco_trajectory.html">MocoTrajectory</a> &amp;&#160;</td>
          <td class="paramname"><em>iterate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>outputPaths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the requested outputs using the model in the problem and the states and controls in the <a class="el" href="class_open_sim_1_1_moco_trajectory.html" title="The values of the variables in an optimal control problem. ">MocoTrajectory</a>. </p>
<p>The output paths can be regular expressions. For example, ".*activation" gives the activation of all muscles. Constraints are not enforced but prescribed motion (e.g., <a class="el" href="class_open_sim_1_1_position_motion.html" title="This class prescribes the value, speed, and acceleration of all coordinates in the model using SimTK:...">PositionMotion</a>) is. The output paths must correspond to outputs that match the type provided in the template argument, otherwise they are not included in the report. </p><dl class="section note"><dt>Note</dt><dd>Parameters in the <a class="el" href="class_open_sim_1_1_moco_trajectory.html" title="The values of the variables in an optimal control problem. ">MocoTrajectory</a> are <b>not</b> applied to the model. </dd></dl>

</div>
</div>
<a id="ab813e9a3a814e117d7e7f5796a36518e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab813e9a3a814e117d7e7f5796a36518e">&#9670;&nbsp;</a></span>checkOrderSystemControls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API void OpenSim::checkOrderSystemControls </td>
          <td>(</td>
          <td class="paramtype">const Model &amp;&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throws an exception if the order of the controls in the model is not the same as the order of the actuators in the model. </p>

</div>
</div>
<a id="abf40fff82cb030c5eeb3ff614f016ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf40fff82cb030c5eeb3ff614f016ee7">&#9670;&nbsp;</a></span>checkPropertyInRangeOrSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::checkPropertyInRangeOrSet </td>
          <td>(</td>
          <td class="paramtype">const Object &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Property&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throw an exception if the property's value is neither in the provided range nor in the provided set. </p>
<p>We assume that <code>p</code> is a single-value property. </p>

</div>
</div>
<a id="aea72d92099e28d9cb83b4049cec8beea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea72d92099e28d9cb83b4049cec8beea">&#9670;&nbsp;</a></span>checkPropertyInSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::checkPropertyInSet </td>
          <td>(</td>
          <td class="paramtype">const Object &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Property&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throw an exception if the property's value is not in the provided set. </p>
<p>We assume that <code>p</code> is a single-value property. </p>

</div>
</div>
<a id="a929e22e5913ca94fe8b9cfd6ec36dd27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929e22e5913ca94fe8b9cfd6ec36dd27">&#9670;&nbsp;</a></span>checkPropertyIsPositive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::checkPropertyIsPositive </td>
          <td>(</td>
          <td class="paramtype">const Object &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Property&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throw an exception if the property's value is not positive. </p>
<p>We assume that <code>p</code> is a single-value property. </p>

</div>
</div>
<a id="ab7e9a2727738c7f770c3797230653077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e9a2727738c7f770c3797230653077">&#9670;&nbsp;</a></span>checkRedundantLabels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API void OpenSim::checkRedundantLabels </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>labels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throws an exception if the same label appears twice in the list of labels. </p>
<p>The argument copies the provided labels since we need to sort them to check for redundancies. </p>

</div>
</div>
<a id="a87f73e666ec1c1f00fb25fbc94a95747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f73e666ec1c1f00fb25fbc94a95747">&#9670;&nbsp;</a></span>convertTableToStorage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API Storage OpenSim::convertTableToStorage </td>
          <td>(</td>
          <td class="paramtype">const TimeSeriesTable &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Storage from a TimeSeriesTable. </p>
<p>Metadata from the TimeSeriesTable is <em>not</em> copied to the Storage. You should use TimeSeriesTable if possible, as support for Storage may be reduced in future versions of <a class="el" href="namespace_open_sim.html" title="The Moco interface is contained within the OpenSim namespace. ">OpenSim</a>. However, Storage supports some operations not supported by TimeSeriesTable (e.g., filtering, resampling). </p>

</div>
</div>
<a id="a796a5573814872a863a4b93ca4ad3138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796a5573814872a863a4b93ca4ad3138">&#9670;&nbsp;</a></span>convertToCasADiDMTranspose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">casadi::DM OpenSim::convertToCasADiDMTranspose </td>
          <td>(</td>
          <td class="paramtype">const SimTK::Matrix &amp;&#160;</td>
          <td class="paramname"><em>simtkMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This converts a SimTK::Matrix to a casadi::DM matrix, transposing the data in the process. </p>

</div>
</div>
<a id="a50fa83db4b660907c92fda46af34e035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50fa83db4b660907c92fda46af34e035">&#9670;&nbsp;</a></span>convertToSimTKMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimTK::Matrix OpenSim::convertToSimTKMatrix </td>
          <td>(</td>
          <td class="paramtype">const casadi::DM &amp;&#160;</td>
          <td class="paramname"><em>casMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This converts a casadi::DM matrix to a SimTK::Matrix, transposing the data in the process. </p>

</div>
</div>
<a id="a4b1a9aa9f611068ee70b20792b9a44de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1a9aa9f611068ee70b20792b9a44de">&#9670;&nbsp;</a></span>createControlNamesFromModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API std::vector&lt;std::string&gt; OpenSim::createControlNamesFromModel </td>
          <td>(</td>
          <td class="paramtype">const Model &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>modelControlIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a vector of control names based on the actuators in the model for which appliesForce == True. </p>
<p>For actuators with one control (e.g. ScalarActuator) the control name is simply the actuator name. For actuators with multiple controls, each control name is the actuator name appended by the control index (e.g. "/actuator_0"); modelControlIndices has length equal to the number of controls associated with actuators that apply a force (appliesForce == True). Its elements are the indices of the controls in the Model::updControls() that are associated with actuators that apply a force. </p>

</div>
</div>
<a id="a66c0e6712096b1eaabe50514204d8c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c0e6712096b1eaabe50514204d8c9f">&#9670;&nbsp;</a></span>createExternalLoadsTableForGait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API TimeSeriesTable OpenSim::createExternalLoadsTableForGait </td>
          <td>(</td>
          <td class="paramtype">Model&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_open_sim_1_1_moco_trajectory.html">MocoTrajectory</a> &amp;&#160;</td>
          <td class="paramname"><em>trajectory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>forceNamesRightFoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>forceNamesLeftFoot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the ground reaction forces, centers of pressure, and torques resulting from Force elements (e.g., <a class="el" href="class_open_sim_1_1_smooth_sphere_half_space_force.html">SmoothSphereHalfSpaceForce</a>), using the model and the trajectory. </p>
<p>Forces and torques are expressed in the ground frame with respect to the ground origin. Hence, the centers of pressure are at the origin. Names of Force elements should be provided separately for elements of the right and left feet. The output is a table formated for use with <a class="el" href="namespace_open_sim.html" title="The Moco interface is contained within the OpenSim namespace. ">OpenSim</a> tools; the labels of the columns distinguish between right ("&lt;&gt;_r") and left ("&lt;&gt;_l") forces, centers of pressure, and torques. The forces and torques used are taken from the first six outputs of getRecordValues(); this order is of use for, for example, the <a class="el" href="class_open_sim_1_1_smooth_sphere_half_space_force.html">SmoothSphereHalfSpaceForce</a> contact model but might have a different meaning for different contact models. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example2_d_walking_8cpp-example.html#a30">example2DWalking.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a70bec286246ccd6fc9ba385ba2b97957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bec286246ccd6fc9ba385ba2b97957">&#9670;&nbsp;</a></span>createPeriodicTrajectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API <a class="el" href="class_open_sim_1_1_moco_trajectory.html">MocoTrajectory</a> OpenSim::createPeriodicTrajectory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_sim_1_1_moco_trajectory.html">MocoTrajectory</a> &amp;&#160;</td>
          <td class="paramname"><em>halfPeriodTrajectory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>addPatterns</em> = <code>{&quot;.*pelvis_tx/value&quot;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>negatePatterns</em> = <code>{&quot;.*pelvis_list.*&quot;,&#160;&quot;.*pelvis_rotation.*&quot;,&#160;&quot;.*pelvis_tz.*&quot;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string, std::string &gt;&gt;&#160;</td>
          <td class="paramname"><em>symmetryPatterns</em> = <code>{{R&quot;(_r(\$))&quot;,&#160;&quot;_l$1&quot;},&#160;{R&quot;(_l(\$))&quot;,&#160;&quot;_r$1&quot;}}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a trajectory covering half the period of a symmetric motion into a trajectory over the full period. </p>
<p>This is useful for simulations of half a gait cycle. This converts time, states, controls, and derivatives; all other quanties from the input trajectory are ignored. If a column in the trajectory does not match addPatterns, negatePatterns, or symmetryPatterns, then the second half of the period contains the same data as the first half.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halfPeriodTrajectory</td><td>The input trajectory covering half a period. </td></tr>
    <tr><td class="paramname">addPatterns</td><td>If a column label matches an addPattern, then the second half of the period for that column is (first_half_trajectory + half_period_value - initial_value). </td></tr>
    <tr><td class="paramname">negatePatterns</td><td>If a column label matches a negatePattern, then the second half of the period for that column is (-first_half_trajectory + 2 * half_period_value). This is usually relevant for only 3D models. </td></tr>
    <tr><td class="paramname">symmetryPatterns</td><td>This argument is a list of pairs, where the first element of the pair is a pattern to match, and the second is a substitution to convert the column label into the opposite column label of the symmetric pair. If a column label matches a symmetryPattern, then its first half-period is copied into the second half of the period for the column identified by the substitution.</td></tr>
  </table>
  </dd>
</dl>
<p>The default values for the patterns are intended to handle the column labels for typical 2D or 3D <a class="el" href="namespace_open_sim.html" title="The Moco interface is contained within the OpenSim namespace. ">OpenSim</a> gait models. The default value for symmetryPatterns warrants an explanation. R"()" is a string literal that permits us to not escape backslash characters. The regex "_r(\/|$)" matches "_r" followed by either a forward slash (which is escaped) OR the end of the string ($). Since the forward slash and end of the string are within parentheses, whatever matches this is captured and is available in the substitution (the second element of the pair) as $1. The default symmetry patterns cause the following replacements:</p><ul>
<li>"/jointset/hip_r/hip_flexion_r/value" becomes "/jointset/hip_l/hip_flexion_l/value"</li>
<li>"/forceset/soleus_r" becomes "/forceset/soleus_l" </li>
</ul>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example2_d_walking_8cpp-example.html#a23">example2DWalking.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a1045cb61806f23d170ebf40a1b107ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1045cb61806f23d170ebf40a1b107ee3">&#9670;&nbsp;</a></span>createStateVariableNamesInSystemOrder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API std::vector&lt;std::string&gt; OpenSim::createStateVariableNamesInSystemOrder </td>
          <td>(</td>
          <td class="paramtype">const Model &amp;&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The map provides the index of each state variable in SimTK::State::getY() from its each state variable path string. </p>
<p>Empty slots in Y (e.g., for quaternions) are ignored. </p>

</div>
</div>
<a id="ab870f25b5f946f89a5df60dcb6117665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab870f25b5f946f89a5df60dcb6117665">&#9670;&nbsp;</a></span>createStateVariableNamesInSystemOrder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API std::vector&lt;std::string&gt; OpenSim::createStateVariableNamesInSystemOrder </td>
          <td>(</td>
          <td class="paramtype">const Model &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; int, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>yIndexMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above, but you can obtain a map from the returned state variable names to the index in SimTK::State::getY() that accounts for empty slots in Y. </p>

</div>
</div>
<a id="a3b8f02f12bea688291032dbe052311d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8f02f12bea688291032dbe052311d6">&#9670;&nbsp;</a></span>createSystemControlIndexMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API std::unordered_map&lt;std::string, int&gt; OpenSim::createSystemControlIndexMap </td>
          <td>(</td>
          <td class="paramtype">const Model &amp;&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The map provides the index of each control variable in the SimTK::Vector return by OpenSim::Model::getControls() from its control name. </p>

</div>
</div>
<a id="ada21b7233f4d453b13086612c60cbe36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada21b7233f4d453b13086612c60cbe36">&#9670;&nbsp;</a></span>createSystemYIndexMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API std::unordered_map&lt;std::string, int&gt; OpenSim::createSystemYIndexMap </td>
          <td>(</td>
          <td class="paramtype">const Model &amp;&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The map provides the index of each state variable in SimTK::State::getY() from its state variable path string. </p>

</div>
</div>
<a id="a96caa7cc52282d844d48bc3314d17384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96caa7cc52282d844d48bc3314d17384">&#9670;&nbsp;</a></span>createVectorLinspace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API SimTK::Vector OpenSim::createVectorLinspace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a SimTK::Vector with the provided length whose elements are linearly spaced between start and end. </p>

</div>
</div>
<a id="a97903aa67e0c6d46260d745c197c2a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97903aa67e0c6d46260d745c197c2a25">&#9670;&nbsp;</a></span>endsWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenSim::endsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if <code>string</code> ends with the substring <code>ending</code>. </p>
<p><a href="https://stackoverflow.com/questions/874134/find-if-string-ends-with-another-string-in-c">https://stackoverflow.com/questions/874134/find-if-string-ends-with-another-string-in-c</a> </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example2_d_walking_8cpp-example.html#a15">example2DWalking.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="ab2e631879e9d2a6d101b4f5014baafb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e631879e9d2a6d101b4f5014baafb4">&#9670;&nbsp;</a></span>filterLowpass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API TimeSeriesTable OpenSim::filterLowpass </td>
          <td>(</td>
          <td class="paramtype">const TimeSeriesTable &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cutoffFreq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>padData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowpass filter the data in a TimeSeriesTable at a provided cutoff frequency. </p>
<p>The table is converted to a Storage object to use the lowpassIIR() method to filter, and then converted back to TimeSeriesTable. </p>

</div>
</div>
<a id="a8ff3b037274379f4f31742a6db884400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff3b037274379f4f31742a6db884400">&#9670;&nbsp;</a></span>format()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string OpenSim::format </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>formatString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Types...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a string in the style of sprintf. </p>
<p>For example, the code <code>format("%s %d and %d yields %d", "adding", 2, 2, 4)</code> will produce "adding 2 and 2 yields 4". </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_custom_implicit_auxiliary_dynamics_8cpp-example.html#a0">exampleCustomImplicitAuxiliaryDynamics.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a2e3c0fe4e0f827309f2791244625748f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3c0fe4e0f827309f2791244625748f">&#9670;&nbsp;</a></span>getFormattedDateTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API std::string OpenSim::getFormattedDateTime </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appendMicroseconds</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;%Y-%m-%dT%H%M%S&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a string with the current date and time formatted as Y-m-dTHMS (year, month, day, "T", hour, minute, second). </p>
<p>You can change the datetime format via the <code>format</code> parameter. If you specify "ISO", then we use the ISO 8601 extended datetime format Y-m-dTH:M:S. See <a href="https://en.cppreference.com/w/cpp/io/manip/put_time">https://en.cppreference.com/w/cpp/io/manip/put_time</a>. </p>

</div>
</div>
<a id="a30ea0f4e9e9582c60e5dfba9c10254fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ea0f4e9e9582c60e5dfba9c10254fe">&#9670;&nbsp;</a></span>getMocoParallelEnvironmentVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API int OpenSim::getMocoParallelEnvironmentVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This obtains the value of the OPENSIM_MOCO_PARALLEL environment variable. </p>
<p>The value has the following meanings:</p><ul>
<li>0: run in series (not parallel).</li>
<li>1: run in parallel using all cores.</li>
<li>greater than 1: run in parallel with this number of threads. If the environment variable is not set, this function returns -1.</li>
</ul>
<p>This variable does not indicate which calculations are parallelized or how the parallelization is achieved. Moco may even ignore or override the setting from the environment variable. See documentation elsewhere (e.g., from a specific <a class="el" href="class_open_sim_1_1_moco_solver.html" title="Once the solver is created, you should not make any edits to the MocoProblem. ">MocoSolver</a>) for more information. </p>

</div>
</div>
<a id="ac2651693a131d710ec2775c3b8ec03f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2651693a131d710ec2775c3b8ec03f3">&#9670;&nbsp;</a></span>getModelOutputReferencePtrs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;SimTK::ReferencePtr&lt;const Output&lt;T&gt; &gt; &gt; OpenSim::getModelOutputReferencePtrs </td>
          <td>(</td>
          <td class="paramtype">const Component &amp;&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeDescendents</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of reference pointers to all outputs whose names (not paths) match a substring defined by a provided regex string pattern. </p>
<p>The regex string pattern could be the full name of the output. Only Outputs that match the template argument type will be returned (double is the default type). Set the argument 'includeDescendents' to true to include outputs from all descendents from the provided component. </p>

</div>
</div>
<a id="a26c339028de63cc21e485c9c13661717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c339028de63cc21e485c9c13661717">&#9670;&nbsp;</a></span>interpolate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API SimTK::Vector OpenSim::interpolate </td>
          <td>(</td>
          <td class="paramtype">const SimTK::Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Vector &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SimTK::Vector &amp;&#160;</td>
          <td class="paramname"><em>newX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignoreNaNs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linearly interpolate y(x) at new values of x. </p>
<p>The optional 'ignoreNaNs' argument will ignore any NaN values contained in the input vectors and create the interpolant from the non-NaN values only. Note that this option does not necessarily prevent NaN values from being returned in 'newX', which will have NaN for any values of newX outside of the range of x. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception</td><td>if x and y are different sizes, or x or y is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d3c4fa14d4de297beb390cadb031ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3c4fa14d4de297beb390cadb031ad4">&#9670;&nbsp;</a></span>make_printable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_sim_1_1make__printable__return.html">make_printable_return</a>&lt;T&gt;::type OpenSim::make_printable </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to types that can be printed with sprintf() (vsnprintf()). </p>
<p>The generic template does not alter the type. </p>

</div>
</div>
<a id="aa258d8737b024554c06553d1d88266c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa258d8737b024554c06553d1d88266c0">&#9670;&nbsp;</a></span>make_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;T&gt; OpenSim::make_unique </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Since Moco does not require C++14 (which contains std::make_unique()), here is an implementation of <a class="el" href="namespace_open_sim.html#aa258d8737b024554c06553d1d88266c0" title="Since Moco does not require C++14 (which contains std::make_unique()), here is an implementation of m...">make_unique()</a>. </p>

</div>
</div>
<a id="ac34b095dbdeec386fa965d3110232f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34b095dbdeec386fa965d3110232f58">&#9670;&nbsp;</a></span>prescribeControlsToModel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API void OpenSim::prescribeControlsToModel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_sim_1_1_moco_trajectory.html">MocoTrajectory</a> &amp;&#160;</td>
          <td class="paramname"><em>iterate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Model &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>functionType</em> = <code>&quot;GCVSpline&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a <a class="el" href="class_open_sim_1_1_moco_trajectory.html" title="The values of the variables in an optimal control problem. ">MocoTrajectory</a> and the associated <a class="el" href="namespace_open_sim.html" title="The Moco interface is contained within the OpenSim namespace. ">OpenSim</a> model, return the model with a prescribed controller appended that will compute the control values from the <a class="el" href="class_open_sim_1_1_moco_solution.html" title="Return type for MocoStudy::solve(). ">MocoSolution</a>. </p>
<p>This can be useful when computing state-dependent model quantities that require realization to the Dynamics stage or later. The function used to fit the controls can either be GCVSpline or PiecewiseLinearFunction. </p>

</div>
</div>
<a id="a56ef06878f1f7f264543d89805c1cd6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ef06878f1f7f264543d89805c1cd6b">&#9670;&nbsp;</a></span>printMessage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void OpenSim::printMessage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>formatString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Types...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a formatted string to std::cout. </p>
<p>A newline is not included, but the stream is flushed. </p>

</div>
</div>
<a id="a4145605aed5f3127a9a7f072c2c34957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4145605aed5f3127a9a7f072c2c34957">&#9670;&nbsp;</a></span>readTableFromFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API TimeSeriesTable OpenSim::readTableFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read in a TimeSeriesTable from file containing scalar elements. </p>
<p>The <code>filepath</code> argument should refer to a STO or CSV file (or other file types for which there is a FileAdapter). This function assumes that only one table is contained in the file, and will throw an exception otherwise. </p>

</div>
</div>
<a id="ab924a2cbfe8ab4871b9035e8b1c8fe90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab924a2cbfe8ab4871b9035e8b1c8fe90">&#9670;&nbsp;</a></span>readTableFromFileT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TimeSeriesTable_&lt;T&gt; OpenSim::readTableFromFileT </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read in a table of type TimeSeriesTable_&lt;T&gt; from file, where T is the type of the elements contained in the table's columns. </p>
<p>The <code>filepath</code> argument should refer to a STO or CSV file (or other file types for which there is a FileAdapter). This function assumes that only one table is contained in the file, and will throw an exception otherwise. </p>

</div>
</div>
<a id="ad599297239897b686094535fa0d26710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad599297239897b686094535fa0d26710">&#9670;&nbsp;</a></span>resample()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeVector , typename FunctionType  = GCVSpline&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TimeSeriesTable OpenSim::resample </td>
          <td>(</td>
          <td class="paramtype">const TimeSeriesTable &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TimeVector &amp;&#160;</td>
          <td class="paramname"><em>newTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resample (interpolate) the table at the provided times. </p>
<p>In general, a 5th-order GCVSpline is used as the interpolant; a lower order is used if the table has too few points for a 5th-order spline. Alternatively, you can provide a different function type as a template argument (e.g., PiecewiseLinearFunction). </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Exception</td><td>if new times are not within existing initial and final times, if the new times are decreasing, or if getNumTimes() &lt; 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a21b59cf52c31b06f9037305535827d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a21b59cf52c31b06f9037305535827d">&#9670;&nbsp;</a></span>simulateIterateWithTimeStepping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API <a class="el" href="class_open_sim_1_1_moco_trajectory.html">MocoTrajectory</a> OpenSim::simulateIterateWithTimeStepping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_open_sim_1_1_moco_trajectory.html">MocoTrajectory</a> &amp;&#160;</td>
          <td class="paramname"><em>iterate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Model&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>integratorAccuracy</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the controls and initial state in the provided iterate to simulate the model using an ODE time stepping integrator (OpenSim::Manager), and return the resulting states and controls. </p>
<p>We return a <a class="el" href="class_open_sim_1_1_moco_trajectory.html" title="The values of the variables in an optimal control problem. ">MocoTrajectory</a> (rather than a StatesTrajectory) to facilitate comparing optimal control solutions with time stepping. Use integratorAccuracy to override the default setting. </p>

</div>
</div>
<a id="ac0ee1403ee61601cddc37f587774b944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ee1403ee61601cddc37f587774b944">&#9670;&nbsp;</a></span>startsWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenSim::startsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if <code>string</code> starts with the substring <code>start</code>. </p>
<p><a href="https://stackoverflow.com/questions/874134/find-if-string-ends-with-another-string-in-c">https://stackoverflow.com/questions/874134/find-if-string-ends-with-another-string-in-c</a> </p>

</div>
</div>
<a id="a2088a2424cbb90feb91a326d047adcbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2088a2424cbb90feb91a326d047adcbb">&#9670;&nbsp;</a></span>visualize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API void OpenSim::visualize </td>
          <td>(</td>
          <td class="paramtype">Model&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Storage&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Play back a motion (from the Storage) in the simbody-visuailzer. </p>
<p>The Storage should contain all generalized coordinates. The visualizer window allows the user to control playback speed. This function blocks until the user exits the simbody-visualizer window. </p>

</div>
</div>
<a id="a3b0b10825c2e3cbf07a35110f81f11b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0b10825c2e3cbf07a35110f81f11b9">&#9670;&nbsp;</a></span>visualize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API void OpenSim::visualize </td>
          <td>(</td>
          <td class="paramtype">Model&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimeSeriesTable&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the same as <a class="el" href="namespace_open_sim.html#a2088a2424cbb90feb91a326d047adcbb" title="Play back a motion (from the Storage) in the simbody-visuailzer. ">visualize(Model, Storage)</a>, except that the states are provided in a TimeSeriesTable. </p>

</div>
</div>
<a id="a8f397045aff484c51aae9aebcbbba9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f397045aff484c51aae9aebcbbba9a1">&#9670;&nbsp;</a></span>writeTableToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSIMMOCO_API void OpenSim::writeTableToFile </td>
          <td>(</td>
          <td class="paramtype">const TimeSeriesTable &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a single TimeSeriesTable to a file, using the FileAdapter associated with the provided file extension. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example2_d_walking_8cpp-example.html#a31">example2DWalking.cpp</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
</body>
</html>
